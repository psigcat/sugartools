# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SugarTools
                                 A QGIS plugin
 Aqueological tools for QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-25
        git sha              : $Format:%H$
        copyright            : (C) 2024 by PSIG
        email                : geraldo@servus.at
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QLineEdit, QPlainTextEdit, QComboBox, QCheckBox
from qgis.gui import QgsFileWidget, QgsSpinBox

from .sugar_tools_dialog import SugarToolsDialog
import os.path
import datetime

from .site_params import sites, symbologies, symbologies_overlays
from .utils import Utils


FIELDS_MANDATORY = ["db_view", "workspace", "thickness"]
FIELDS_SECTIONS = ["ew", "ew_inverted", "se", "se_inverted"]


class SugarTools:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'SugarTools_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Sugar Tools')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('SugarTools', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = self.plugin_dir + '/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Sugar Tools'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Sugar Tools'),
                action)
            self.iface.removeToolBarIcon(action)


    def load_db_views(self):
        """ Load database views """

        self.dlg.db_view.clear()
        self.dlg.db_view.addItem("localtabac")


    def load_site_params(self):
        """ Load site params from configuration """

        self.dlg.site.clear()
        for site in sites:
            self.dlg.site.addItem(site)


    def load_symbologies(self):
        """ Load symbologies from configuration """

        self.dlg.symbologies.clear()
        for symbology in symbologies:
            self.dlg.symbologies.addItem(symbology)


    def load_symbologies_overlays(self):
        """ Load overlay symbologies from configuration """

        self.dlg.symbologies_overlays.clear()
        for symbology in symbologies_overlays:
            self.dlg.symbologies_overlays.addItem(symbology)


    def get_widget_data(self, fieldname):
        """ Get widgets and its data """

        widget = None
        data = None
        if not hasattr(self.dlg, fieldname):
            return None, None
        widget = getattr(self.dlg, fieldname)
        if type(widget) == QLineEdit:
            data = widget.text()
        elif type(widget) == QPlainTextEdit:
            data = widget.toPlainText()
        elif type(widget) is QgsFileWidget:
            data = widget.filePath()
        elif type(widget) is QgsSpinBox:
            data = widget.text()
        elif type(widget) is QComboBox:
            data = widget.currentText()
        elif type(widget) == QCheckBox:
            data = widget.isChecked()
        else:
            self.iface.messageBar().pushMessage(f"Type of component not supported for field '{fieldname}': {type(widget)}")
        return widget, data


    def check_mandatory(self):
        """ Check if mandatory fields do have values """

        for field in FIELDS_MANDATORY:

            widget, widget_data = self.get_widget_data(field)
            if widget_data in ('(Seleccionar)', '--') or widget_data == '':
                self.iface.messageBar().pushMessage(f"Mandatory field without information: {field}")
                widget.setFocus()
                return False

        return True


    def check_sections(self):
        """ Check if at least one section is selected """

        for field in FIELDS_SECTIONS:

            widget, widget_data = self.get_widget_data(field)
            if widget_data:
                return True

        self.iface.messageBar().pushMessage(f"At least one section has to be selected")
        return False



    def createConfig(self):
        """ Create a geopackage with list of tables """

        ###Folder name:
        today = datetime.date.today()
        folder_name = "Sec-" + self.dlg.site.currentText() + "-" + str(self.dlg.thickness.text()) + "--" + today.strftime("%Y") + "-" + today.strftime("%m") + "-" + today.strftime("%d")
        print(folder_name)

        ###Paths:
        path_arqueotools = os.path.dirname(os.path.abspath(__file__))
        print(path_arqueotools)
        path_gpkg = os.path.join(self.dlg.workspace.filePath(), folder_name, folder_name+".gpkg")
        gpkg_layername = "|layername="
        print(path_gpkg)

        #Paths de taules de la geodatabase:
        all_table = path_gpkg + gpkg_layername + "all_table" #Path de la taula amb totes les dades
        restr_table = path_gpkg + gpkg_layername + "restr_table" #Path taula restringida a coordenades especificades
        levels_table = path_gpkg + gpkg_layername + "levels_table" #Path a taula restringida a UA's especificades
        overlay_table = path_gpkg +  gpkg_layername + "overlay_table" #Path a taula amb dades del Overlay
        sec_table = path_gpkg +  gpkg_layername + "sec_table" #Path per taula de secció
        overlay_sec_table = path_gpkg +  gpkg_layername + "overlay_sec_table" #Path per taula de secció Overlay
        bl_table = path_gpkg +  gpkg_layername + "bl_table" #Path per taula de blocs
        bl_table_ampliada = path_gpkg +  gpkg_layername + "bl_table_ampliada" #Path per taula ampliada de blocs

        #Declarar variables que s'utilitzaran més endavant
        data_table = self.dlg.db_view.currentText()
        xmin = xmax = ymin = ymax = 0
        empty_lyrfile = ""
        empty_overlay_lyr = ""
        lyrfile = self.dlg.symbologies.currentText()
        sql_overlay = self.dlg.overlay_layer.text()
        overlay_lyrfile = self.dlg.symbologies_overlays.currentText()

        if self.dlg.xmin.isChecked() and self.dlg.xmax.isChecked() != 0 and self.dlg.ymin.isChecked() != 0 and pself.dlg.ymax.isChecked() != 0:
            bol_coords = True
        else:
            bol_coords = False

        if self.dlg.site.currentText() != "":
            bol_site = True
        else:
            bol_site = False
        
        if self.dlg.symbologies.currentText() != "":
            bol_simb = True
        else:
            bol_simb = False

        if self.dlg.symbologies_overlays.currentText() != "":
            bol_overlay = True
        else:
            bol_overlay = False

        par_block = self.dlg.option_points.isChecked()
        par_dibblock = self.dlg.option_paint.isChecked()
        if not par_block and par_dibblock: #Si s'activa el dibuix de blocs però no està activada la selecció de punts de blocs, activa aquesta ultima.
            bol_block = True
        elif not par_block and not par_dibblock:
            bol_block = False
        elif par_block:
            bol_block = True

        #Set UA's query
        form_levels = self.dlg.restricted_units.text()
        if form_levels != "":
            levels_str, levels_query = Utils.sec_set_uas(form_levels)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = SugarToolsDialog()

        self.load_db_views()
        self.load_site_params()
        self.load_symbologies()
        self.load_symbologies_overlays()

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:

            self.check_sections()
            self.check_mandatory()
            self.createConfig()
